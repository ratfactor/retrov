<!DOCTYPE html>
<html lang="en">
<head>
    <title>RetroV Demo/Test Page</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { background: #000; color: #FFF; font-size: 18px; }
        a, a:hover, a:visited { color: #F0A; }
        pre { padding: 1em; border: 1px solid orange; font-size: 0.9em; }
        .container { padding: 1em; border: 1px solid #0cf;  }
        pre,code { color: #F4F; }
        .aqua {
            background: #0CF; color: black; padding: 3px;
            display: inline-block; margin: 5px;
         }
        .orange {
            background: orange; color: black; padding: 3px;
            display: inline-block; margin: 5px;
        }
        .bold { font-weight: bold; }
        .bad-element {border: 1px red dashed;}
    </style>
    <script src="retrov.js"></script>
</head>
<body>

<center> <!-- A center tag! Now that's retro! -->
    <h1>RetroV Demo/Test Page</h1>
    <img src="./retrov.svg" alt="RetroV 1970s colors svg logo">
</center>

<script>
function container(){
    var script = document.currentScript;
    var output = document.createElement('div');
    output.className = "container";
    script.parentNode.insertBefore(output, script);
    window.test_container = output;
    return output;
}
</script>

<h2>Simple Rendering</h2>

<h3>Single elements</h3>

<script data-mirror>
RV.render(container(), 'Hello world!');
</script>

<script data-mirror>
RV.render(container(), ['div', 'Hello world in a div tag!']);
</script>

<script data-mirror>
RV.render(container(), ['div.aqua', 'Class shorthand.']);
</script>

<script data-mirror>
RV.render(container(), ['.aqua', 'Class shorthand, implicit div.']);
</script>

<h3>Nested elements</h3>
<script data-mirror>
RV.render(container(),
    ['.aqua', 'Look at those',
        ['.orange', 'Large'],
        ['.orange', 'Shoes'],
    ]
);
</script>

<p>Arrays of sibling elements are okay.  <i>(Note that they cannot start with a
    string because that will look like an element's tag name.)</i></p>
<script data-mirror>
RV.render(container(), [
    ['.aqua', 'Aunt', [
         ['.orange', 'Cousin 1'],
         ['.orange', 'Cousin 2'],
    ]],
    ['.aqua', 'Uncle', [
        ['.orange', 'Cousin A'],
        ['.orange', 'Cousin B'],
        ['.orange', 'Cousin C'],
    ]],
]);
</script>

<p>Numbers and arrays of numbers are okay.</p>
<script data-mirror>
RV.render(container(),
    ['.aqua', 4, [5, 6, 7], 8, 9]
);
</script>


<h2>Function 'components'</h2>

<p>A function is treated as a callable 'component'.</p>
<script data-mirror>
function Foo(){ return ['.orange', 'function Foo()']; }
RV.render(container(), Foo);
</script>

<p>Technique: pre-baking a closure with some data as a component:</p>
<script data-mirror>
function Bar(num){
    return function(){
        return ['.orange',
            'function Bar(',
            ['.aqua', num],
            ')',
        ];
    };
}
RV.render(container(), Bar(42));
</script>

<p>Note that passing a function to RetroV is not the same as calling
a function and passing the <i>result</i>, which is also a useful thing
to do:</p>
<script data-mirror>
function baz(num){
    return ['.orange',
        'baz(',
        ['.aqua', num],
        ')',
    ];
}
RV.render(container(), baz(42));
</script>

<p>Components can be nested:
<script data-mirror>
function A(){ return ['.orange', 'A', B]; }
function B(){ return ['.aqua',   'B', C]; }
function C(){ return ['.orange', 'C']; }
function Z(){ return ['.orange', 'Z']; }
function Y(){ return ['.aqua',    Z, 'Y']; }
function X(){ return ['.orange',  Y, 'X']; }
RV.render(container(), ['div', A, X]);
</script>

<p>You can manage state how ever you like. Here, it's with
a single global variable <code>goat_count</code>:
<script data-mirror>
var goat_container = container();
var goat_count = 0;

function render_goats(){
    RV.render(goat_container,
        ['div.aqua',
            ['button',
                {
                    onclick: function(){
                        goat_count++;
                        render_goats();
                    }
                },
                "Goat",
            ],
            " Goat count: ",
            ['div.orange', goat_count],
    ]);
}

render_goats();
</script>

<p>TODO: test/demonstrate state here when I implement it</p>


<script>
// This helper displays the source of script tags:

/*/ The Mirror of Galadriel 2
 *  Copyright 2023 Dave Gauer (ratfactor.com)
 *  Released under the MIT License.
/*/
document.addEventListener("DOMContentLoaded", function(e) {
    var scripts = document.querySelectorAll('script[data-mirror]');
    if(scripts.length<1){
        console.log("Galadriel's Mirror 2: No scripts with data-mirror found.");
    }
    scripts.forEach(function(script){
        // remove initial blank line from script (if any)
        var text = script.innerHTML.replace(/^\r?\n/, '');
        // create <pre> to mirror text contents
        var mirror = document.createElement('pre');
        mirror.innerHTML = text;
        script.parentNode.insertBefore(mirror, script);
    });
});
</script>
</body>
</html>
